# Java学习笔记

## 继承

> 子类继承父类，在java中使用extends关键字进行继承。只支持单继承。

- 子类不会继承父类的构造方法。
- 子类会继承父类的私有属性，但是不能直接进行操作，可以通过公开的Set和get方法进行操作。
- 子类不会继承父类的静态属性和静态方法，只是和父类共享，但实际所属权还是父类的。
- 在调用子类构造器之前，默认会调用父类的无参构造方法。但是一但在子类中指定了父类构造器的方法，则不会默认调用。
- @Override注解，能够检测方法是否为重写父类方法。

### This和Super

- this：指向当前类的实例对象的一个指针。

> 使用this()可以调用当前的兄弟构造器，但是必须在构造器内的第一行。

- super：指向父类的实例对象的一个指针。

> 可以在子类中通过super调用父类的成员变量和成员方法。

## 包

- 同一个包内的类可以直接调用。
- 不在同一个包中的类需要使用import进行导入
- 使用import导入的类，类名不能够重复，仅能导入一个。需要使用的时候，一个使用直接的类名，其他用类名＋包名

## 权限修饰符

权限修饰符，用来控制一个成员能够被访问的范围。

可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围会被限制。

|  修饰符   | 同一个类中 | 同一个包中的其他类 | 不同包下的子类 | 不同包下的无关类 |
| :-------: | :--------: | :----------------: | :------------: | :--------------: |
|  private  |     ✅      |         ❌          |       ❌        |        ❌         |
|   默认    |     ✅      |         ✅          |       ❌        |        ❌         |
| protected |     ✅      |         ✅          |       ✅        |        ❌         |
|  public   |     ✅      |         ✅          |       ✅        |        ✅         |

> 修饰符范围：private < 默认 < protected < public

## Final

- final关键字是最终的意思，可以修饰类、方法、变量
- 修饰符：表明该类是最终类，不能被继承
- 修饰方法：表明该方法时最终方法，不能被重写
- 修饰变量：表明改变考量第一次赋值后，不能再次被赋值（有且仅能被赋值一次）
- 对变量赋值以后，不能再更改。（这里指的更改是，再程序内部通过语句更改）

注意：

- final修饰的变量是基本类型，那么变量的值不能够改变。
- final修饰的变量是引用类型，那么变量存储的地址值不能发生改变，但是地址指向的具体的对象是可以改变的。

## 常量

- 常量是使用了public static final修饰的成员变量，必须有初始化的值，执行的过程中其值不能够被改变。
- 常量的作用和好处：可以用作于系统的配置信息，方便程序的维护，同时也能提高可读性，
- 在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。类似于C语言中的宏
- 这样替换的好处是，再运行时程序的性能和使用常量的性能一致。

> 命名规范：变量名称全部使用大写的字母，单词间使用下划线隔开。

## 枚举

- 枚举是java中的一种特殊类型。

- 枚举的作用：是为了做信息的标志和信息的分类。
- 定义格式：

```java
// 修饰符 enum 枚举名称{枚举值1,枚举值2,...}
public enum Color{
    RED,BLUE,GREEN,YELLO;
}
```

- 反编译后枚举类。

```java
public final class Color extends java.lang.Enum<Color> {
  public static final Color RED;
  public static final Color BLUE;
  public static final Color GREEN;
  public static final Color YELLO;
  public static Color[] values();
  public static Color valueOf(java.lang.String);
  static {};
}
```

#### 特征

- 枚举类都是继承了枚举类型：java.lang.Enum
- 枚举都是最终类，不可以被继承。
- 枚举类的构造器都是私有的，枚举对外不能创建对象。
- 枚举类的第一行默认都是罗列枚举对象的名称的。
- 枚举类相当于是多例模式。

## 抽象类和抽象方法

- 使用abstract关键字对类进行修饰就是抽象类。对方法进行修饰就是抽象方法。
- 一个类中只要包含抽象方法，则该类就一定是抽象类。但抽象类中不一定全部为抽象方法。
- 抽象类只能够被继承，抽象方法不能自己实现方法体。
- 一个类继承某个抽象类，要么这个类也成为抽象类，要么就必须实现父类中的所有的**抽象**方法。
- 普通类拥有的特征，抽象类全部都具有。如属性、普通方法、构造方法等。
- 不能用abstract修饰变量、代码块、构造方法。
- 重点：抽象类不能被实例化，无论是否包含抽象方法。即不能使用抽象类实例化具体的对象。反证法证明。

## final和abstact的关系

- 互斥关系：final不能被继承，abstract必须被继承
- abatract定义的抽象类作为模板让子类继承，final定义的类不允许被继承。
- 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。

## 接口

- 接口定义

```java
public interface interFace{
    // 接口中只能包含方法的声明，不能直接实现方法体。
    
    // 可以包含常量
    public static final String name = "codermast";//可以去掉 public static final即默认就为此

    // 可以包含方法声明
    public void run();
    
    // 可以包含抽象方法
    public abstract void eat();
}
```

- JDK8之前接口中只能有抽象方法和常量。
- 类使用implement关键字实现接口。接口可以多实现，一个类可以实现多个接口。
- 类实现接口以后，必须实现接口中所有的方法。
- 接口和接口可以使用extends关键字实现多继承，一个接口可以继承多个接口。
- JDK8以后添加了默认方法和静态方法（可以实现方法体）

```java
public interface interFace{
    // 默认方法：只能由实现类调用
    default void seeHello(){
        System.out.println("Hello World!");
        
        run();	// 调用私有方法
    }
    
    // 静态方法：直接使用接口名调用，但依旧不能实例化对象。
    static void toLearnJava(){
    	System.out.println("Learning Java...");
    }
    
    // 私有方法：JDK 9 开始支持，必须在接口内部才能被访问
    private void run(){
        System.out.println("Java在运行中...");
    }
}
```

- 一个类实现多个接口时，多个接口中出现同名方法，此时会重写该方法。否则无法运行。

## 多态

- 多态即为：同类型的对象，执行同一个行为，会表现出不同的行为特征。

```java
父类类型 对象名称 = new 子类构造器;
接口 对象名称 = new 实现类构造器;
```

- 即便形式上的类型是父类类型，但是实际上是执行的子类的具体方法。但是对于变量来说，直接访问的父类变量。
- 多态是一种行为多态，即仅对方法生效。对于变量不生效，变量使用的父类的变量。
- 只能将子类的对象赋值给父类，但是不能将父类的对象赋值给子类。

## 内部类

### 静态内部类



### 成员内部类



### 局部内部类



### 匿名内部类



## 常用API

### Object

- toString()

> 默认返回当前对象在堆内存中的地址信息：类的全险名@内存地址

- equals()

> 默认比较当前对象和另一个对象的地址是否相同，相同返回true，不同返回fasle

- isNull()

> 判断变量是否为null，为null返回true。

### StringBulder

> StringBulider是一个可变的字符串类，我们可以把他看作是一个对象容器。
>
> 作用：提高字符串的操作效率。eg.拼接、修改等操作。

#### 构造器

- StringBuilder()

> 创建一个空白的可变的字符串对象，不包含任何内容。

- StringBuilder(String str)

> 创建一个指定字符串内容的可变字符串对象。

#### 常用API

- append(任意类型)

> 添加数据并返回StringBuilder对象本身

- reverse()

> 将对象的内容反转

- length()

> 返回对象内容的长度

- toString()

> 将StringBuilder对象转换成String